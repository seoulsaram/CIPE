
## 연산자
- `&&` : 좌항, 우항의 값이 모두 참일 때 true
- `||` : 좌항, 우항의 값 중 하나만 참일 경우 true
- `&` (비트AND) : 좌항과 우항에 있는 값을 2진수로 바꿔서 그 진수들이 모두 참일때만 true
	- `10&7` 풀이
	- 10을 2진수로 변환 -> 1010
	- 7을 2진수로 변환 -> 111
	- 비트수를 맞춰주기 위해 1010과 0111을 대조
	- 대조 결과 true인 것에만 1을 주면 0010
	- 0010을 10진수로 바꾸면 => 2
	- 답은 2
- `|` (비트 OR): 좌항과 우항에 있는 값을 2진수로 바꿔서 그 진수들 중 하나만 참이면 true
	- `10|7` 풀이
	- 10을 2진수로 변환 -> 1010
	- 7을 2진수로 변환 -> 111
	- 비트수를 맞춰주기 위해 1010과 0111을 대조
	- 대조 결과 true인 것에만 1을 주면 1111
	- 1111을 10진수로 바꾸면 => 15
	- 답은 15
- `~` (비트 Not) : 이건 어려우니까 아묻따 외우기
	- `~10` 풀이
	  - 10이 양수이므로 10에 1을 더한 뒤에 마이너스를 붙여줌 -
	  - 답 -11
	- `~-10` 풀이
	  -10이 음수이므로 1을 빼준 뒤 +를 붙여줌
	  - 답 9

- `^` (비트 XOR) : 두 진수가 다를경우 true
	- `10^7` 풀이
	  - 10을 2진수로 변환 -> 1010
	  - 7을 2진수로 변환 -> 111
	  - 비트수를 맞춰주기 위해 1010과 0111을 대조
	  - 1 vs 0 => 1
	  - 0 vs 1 => 1
	  - 1 vs 1 => 0 (두 수가 같기때문에)
	  - 0 vs 1 => 1
	  - 1101을 10진수로 바꾸면 13
	  - 답은 13
- `<<` (좌 비트 이동) : 우항의 숫자만큼 비트를 좌측으로 이동하며 0을 붙여줌
	- `10 << 2` 풀이
	  - 10을 2진수로 변환 -> 1010
	  - 2자리수만큼 왼쪽으로 이동시키면 1010 00
	  - 101000을 10진수로 바꾸면 -> 40
	  - 답 40
-`>>` (우 비트 이동) :  우항의 숫자만큼 오른쪽 비트를 자름
	- `10 >> 2` 풀이
	  - 10을 2진수로 변환 -> 1010
	  - 2만큼 오른쪽 비트 삭제 -> 10
	  - 10을 10진수로 바꾸면 -> 2
	  - 답 2


getchar() / putchar()
- 단일 문자를 입출력하는 버퍼링 출력 함수
- 
gets() / puts()
- 문자열을 입출력하는 입출력함수

---

## print
- %.1f   :  소수점 1자리까지 출력한다.
- %03d   :  3개의 공간을 확보하고 빈 공간에 0을 채운 뒤 숫자 출력
  - `int i = 3;  printf("%03d", i);` => 003
  - `int i = 12; printf("%03d", i)` => 012
  - `int i = 2300; printf("%03d",i)` => 2300
  - `float i = 100.56; printf("%3.1f", i)` => 100.6 (반올림 함)
  - `3.1`에서 `3`은 **전체 출력 최소 너비**인데, 여기선 `100.6` 자체가 5자이므로 이 옵션은 무시됨.


### 정수 관련 형식 지정자

| 지정자  | 의미                        | 예시 출력        |
| ---- | ------------------------- | ------------ |
| `%d` | 부호 있는 10진수 (int)          | `123`, `-45` |
| `%i` | `%d`와 동일                  | `123`        |
| `%u` | 부호 없는 10진수 (unsigned int) | `123`        |
| `%o` | 8진수 (octal)               | `0173`       |
| `%x` | 16진수 (소문자)                | `7b`         |
| `%X` | 16진수 (대문자)                | `7B`         |

### 실수 형식 지정자
|지정자|의미|예시 출력|
|---|---|---|
|`%f`|소수점 표시 (고정 소수점)|`3.14`|
|`%e` / `%E`|지수 표기법 (과학적 표기법)|`3.14e+00` / `3.14E+00`|
|`%g` / `%G`|상황에 따라 `%f` 또는 `%e`로 자동 선택|`3.14`, `1e+06`|
|`%.2f`|소수점 둘째 자리까지 출력|`3.14`|

### 문자 & 문자열 형식 지정자
|지정자|의미|예시 출력|
|---|---|---|
|`%c`|문자 1개|`A`|
|`%s`|문자열|`Hello`|
|`%.5s`|앞에서 최대 5글자만 출력|`Hello` or `Hell`|


### 포인터 & 특수값
|지정자|의미|예시 출력|
|---|---|---|
|`%p`|포인터 주소 출력 (16진수)|`0x7ffeedccba40`|
|`%%`|`%` 자체를 출력|`%`|


### 서식 옵션 조합 예시
| 데이터 종류 | 대표 지정자           |
| ------ | ---------------- |
| 정수     | `%d`, `%u`, `%x` |
| 실수     | `%f`, `%e`, `%g` |
| 문자/문자열 | `%c`, `%s`       |
| 포인터    | `%p`             |
| 특수 출력  | `%%`             |

---

## `scanf()`
-  C언어에서 **사용자 입력을 받는 함수**


---
## 포인터

> **"어떤 변수의 메모리 주소를 저장하는 변수"**

쉽게 말해:

- **변수는 값(value)을 저장**
- **포인터는 주소(address)를 저장**


```c
int a = 10;         // 일반 변수
int *p = &a;        // 포인터 변수: a의 주소를 저장
```

| 표현   | 의미                         |
| ---- | -------------------------- |
| `a`  | 값: 10                      |
| `&a` | 변수 `a`의 **주소** (ex: 0x100) |
| `p`  | 주소를 저장하는 포인터 변수            |
| `*p` | 포인터가 가리키는 **주소의 값** (즉, a) |

### 포인터 기본 문법 요약

| 문법        | 의미                             |
| --------- | ------------------------------ |
| `*`       | 포인터 선언 or **역참조(dereference)** |
| `&`       | **주소 연산자** (변수의 주소를 얻음)        |
| `int *p;` | `int` 값을 가리키는 포인터 선언           |
| `p = &a;` | 포인터에 변수의 주소를 저장                |
| `*p`      | 포인터가 가리키는 **값을 읽음/변경**         |

### 자주 쓰이는 포인터 종류
| 종류       | 예시                         |
| -------- | -------------------------- |
| 기본 포인터   | `int *p`                   |
| 이중 포인터   | `int **pp` (포인터를 가리키는 포인터) |
| 함수 포인터   | `int (*fp)(int)`           |
| void 포인터 | `void *vp` (타입 미정 포인터)     |


### 그림으로 쉽게 설명
```c
int a = 10;
int *p = &a;

[메모리 구조 예시]

a: [10]       ← a의 값
p: [&a]       ← a의 주소 저장
*p → 10       ← p가 가리키는 값

```


```c
#include <stdio.h>

int main() {
    int a = 42;
    int *p = &a;

    printf("a의 값: %d\n", a);      // 42
    printf("a의 주소: %p\n", &a);   // ex: 0x7ff...
    printf("p의 값(=a의 주소): %p\n", p); // &a
    printf("*p (a의 값): %d\n", *p);     // 42

    *p = 99;  // 역참조를 통해 a의 값을 바꿈
    printf("a의 새로운 값: %d\n", a); // 99

    return 0;
}

```



### 구조체 포인터 `->`
구조체 포인터가 가리키는 구조체 멤버에 접근할 때 사용

```c
struct Person {
    char name[20];
    int age;
};

struct Person p;
struct Person *ptr = &p;

```

- `p.age` : 구조체 변수 직접 접근
- `ptr->age` : 포인터를 통해 접근
```c
// ptr->age 는 사실 이렇게 생략된 것
(*ptr).age

// -> 는 다음과 같은 축약 표현이다.
ptr->age == (*ptr).age
```



---

## 연산 주의사항
1. 정수 나누기 정수는 정수다.
	1. 100 / 300 은 0.33333이지만 정수와 정수를 나눈 것이므로 소수점을 잘라 0이 된다.
	2. 그리고 이 값을 float타입의 변수에 넣으면 0.0이 됨
		1. float i = 100 / 300;  => i = 0.0



---

## 문제풀이

```c
#include <stdio.h>

void func(int** arr, int size){
  for(int i=0; i<size; i++){
     *(*arr + i) = (*(*arr+i) + i) % size;
  }
}

int main(){
  int arr[] = {3,1, 4, 1, 5};
  int* p = arr;
  int** pp = &p;
  int num = 6;
  
  func(pp, 5);  
  
  num = arr[2];
  printf("%d", num);  
  return 0;
}

```

이 문제에서 질문 
1. `int* p = arr;` 포인터 변수에는 &arr이렇게 할당해야 에러가 안나는거 아닌가? 
	1. `arr`은 배열 이름이지만, 배열 이름은 배열의 첫 번째 요소의 주소 (`&arr[0]`)로 자동 변환 돼!
	2. 즉, `int* p = arr;`는 사실상 `int* p = &arr[0];`과 같아!

2. func의 첫번째 인자로 포인터변수를 넘기고있는데, 이때 func정의할때 voidfunc (int arr, int size) 라고하면 어떻게 되나? 
	1. `int arr과 int** arr`은 그냥 타입아 아예 다른거라 에러남.
3. `*(*arr + i)` 이건 어떤 문법이지?
	1. `arr`는 `int**` (이중 포인터)
	- `*arr`는 `int*` (정수 배열 시작 주소)
	- `*arr + i`는 → `i`번째 요소 주소 (주소 + i)
	- `*(*arr + i)`는 → 그 주소에 있는 **값**
	- 즉, `*(*arr + i)`는 **arr[i]에 접근하는 것과 완전히 동일**!
4. `*(*arr + i) = (*(*arr + i) + i) % size;`
	1. `arr[i] = (arr[i] + i) % size;` 와 동일한 효과!




### 소수를 2진수로 변환

예: 0.625

```
0.625 × 2 = 1.25   → 정수: 1  
0.25 × 2  = 0.5    → 정수: 0  
0.5 × 2   = 1.0    → 정수: 1  (끝)

→ 정수들 이어붙이기 → .101
```


예 : 45.1875
```
정수 부분 : 101101

소수 부분
0.1875 × 2 = 0.375 → 정수 0 
0.375 × 2 = 0.75 → 정수 0 
0.75 × 2 = 1.5 → 정수 1 
0.5 × 2 = 1.0 → 정수 1 → 끝!

```


주의할 점은
- 곱하기 2를 한 결과에서 정수를 뺀 소수 부분만 계속해서 곱하기 2를 해줘야 한다는 점.


소수가 무한반복되는 경우도 있어!
```
0.1 × 2 = 0.2   → 0  
0.2 × 2 = 0.4   → 0  
0.4 × 2 = 0.8   → 0  
0.8 × 2 = 1.6   → 1  
0.6 × 2 = 1.2   → 1  
0.2 × 2 = 0.4   → 반복 시작!
```



### 전위/후위연산자 

```c

#include<stdio.h> 

int main() {
	int a, b;  
	a = 4 * ( 1 / 2 ); 
	b = a++; 
	printf("%d", b); 
	return 0;
}

```

`b = a++;` 는 b에 a를 먼저 할당 한 뒤 `a = a + 1`을 실행하는 것
만약 `b = ++a;` 였다면 `a = a + 1`을 먼저 실행한 뒤 b에 a를 할당함.
위의 경우 b는 0임



### `()` 연산자

> 이건 **콤마 연산자(comma operator)**를 사용한 표현이야.  
> 즉, 자료구조가 아니라 **"여러 식을 순서대로 실행하고, 마지막 값을 결과로 쓰는 연산"**이야.

```c
int a = ( 10, 20 );
```

- `10`은 실행되지만 결과는 버려지고,
- `a = 20;` 이랑 똑같은 효과!

```c

int a = (printf("hello\n"), 42);

// hello 출력
// 그리고 `a`에는 `42`가 들어가 있음!


int c = ( 10, (20, 30), 40 );
// `10` → 평가됨 (버려짐)
// `(20, 30)` → `20` 평가 후 `30`이 남음
// 그 다음에 `40` → 최종 결과는 `40`

```

